const express = require('express');
const path = require('path');
const fs = require('fs');
const logger = require('../utils/logger');
const { catchAsync, AppError } = require('../utils/errorHandler');

const router = express.Router();

/**
 * Serve audio files generated by ElevenLabs
 */
router.get('/:filename', catchAsync(async (req, res) => {
  const { filename } = req.params;
  
  // Validate filename to prevent directory traversal
  if (!filename || filename.includes('..') || filename.includes('/') || filename.includes('\\')) {
    throw new AppError('Invalid filename', 400);
  }

  const audioDir = path.join(__dirname, '../../temp/audio');
  const filepath = path.join(audioDir, filename);

  logger.info('Audio file requested', { filename, filepath });

  // Check if file exists
  if (!fs.existsSync(filepath)) {
    throw new AppError('Audio file not found', 404);
  }

  try {
    // Get file stats
    const stats = fs.statSync(filepath);
    const fileSize = stats.size;

    // Set appropriate headers
    res.set({
      'Content-Type': 'audio/mpeg',
      'Content-Length': fileSize,
      'Accept-Ranges': 'bytes',
      'Cache-Control': 'public, max-age=3600', // Cache for 1 hour
      'Access-Control-Allow-Origin': '*'
    });

    // Handle range requests for audio streaming
    const range = req.headers.range;
    if (range) {
      const parts = range.replace(/bytes=/, "").split("-");
      const start = parseInt(parts[0], 10);
      const end = parts[1] ? parseInt(parts[1], 10) : fileSize - 1;
      const chunksize = (end - start) + 1;

      const stream = fs.createReadStream(filepath, { start, end });

      res.status(206).set({
        'Content-Range': `bytes ${start}-${end}/${fileSize}`,
        'Content-Length': chunksize
      });

      stream.pipe(res);
    } else {
      // Send entire file
      const stream = fs.createReadStream(filepath);
      stream.pipe(res);
    }

    logger.info('Audio file served', {
      filename,
      fileSize,
      rangeRequest: !!range
    });

  } catch (error) {
    logger.error('Failed to serve audio file', {
      error: error.message,
      filename,
      filepath
    });
    throw new AppError('Failed to serve audio file', 500);
  }
}));

/**
 * List available audio files (for debugging)
 */
router.get('/', catchAsync(async (req, res) => {
  const audioDir = path.join(__dirname, '../../temp/audio');
  
  if (!fs.existsSync(audioDir)) {
    return res.json({ files: [] });
  }

  try {
    const files = fs.readdirSync(audioDir).map(filename => {
      const filepath = path.join(audioDir, filename);
      const stats = fs.statSync(filepath);
      
      return {
        filename,
        size: stats.size,
        created: stats.birthtime,
        modified: stats.mtime,
        url: `/audio/${filename}`
      };
    });

    res.json({
      files,
      count: files.length,
      totalSize: files.reduce((sum, file) => sum + file.size, 0)
    });

  } catch (error) {
    logger.error('Failed to list audio files', {
      error: error.message
    });
    throw new AppError('Failed to list audio files', 500);
  }
}));

/**
 * Delete old audio files
 */
router.delete('/cleanup', catchAsync(async (req, res) => {
  const audioDir = path.join(__dirname, '../../temp/audio');
  const maxAgeHours = parseInt(req.query.maxAge) || 24;
  
  if (!fs.existsSync(audioDir)) {
    return res.json({ message: 'Audio directory does not exist', deleted: 0 });
  }

  try {
    const files = fs.readdirSync(audioDir);
    const maxAge = maxAgeHours * 60 * 60 * 1000; // Convert to milliseconds
    const now = Date.now();
    let deletedCount = 0;
    let deletedSize = 0;

    files.forEach(filename => {
      const filepath = path.join(audioDir, filename);
      const stats = fs.statSync(filepath);
      
      if (now - stats.mtime.getTime() > maxAge) {
        deletedSize += stats.size;
        fs.unlinkSync(filepath);
        deletedCount++;
      }
    });

    logger.info('Audio cleanup completed', {
      deletedCount,
      deletedSize,
      maxAgeHours
    });

    res.json({
      message: 'Cleanup completed',
      deleted: deletedCount,
      deletedSize,
      maxAgeHours
    });

  } catch (error) {
    logger.error('Failed to cleanup audio files', {
      error: error.message
    });
    throw new AppError('Failed to cleanup audio files', 500);
  }
}));

module.exports = router;
